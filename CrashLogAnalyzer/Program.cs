using Discord;
using Discord.WebSocket;
using DotNetEnv;
using static CrashLogAnalyzer.ArcDPS;
using static CrashLogAnalyzer.Interference;
using static CrashLogAnalyzer.Signatures;
using static CrashLogAnalyzer.Traces;

namespace CrashLogAnalyzer;

public partial class Program
{
    private DiscordSocketClient _client = new();
    private LogParser log = new();
    private readonly Color _blue = new(4, 55, 242);
    private readonly EmbedFooterBuilder _embedFooterBuilder = new EmbedFooterBuilder()
        .WithText("Generated by Crash Log Analyzer")
        .WithIconUrl("https://i.imgur.com/Xafh24a.png");

    static Task Main(string[] args) => new Program().MainAsync();

    public async Task MainAsync()
    {
        Env.Load();
        string? token = Environment.GetEnvironmentVariable("DISCORD_TOKEN");
        if (token is null || token.Length == 0)
        {
            ConsoleTrace("Discord token not set or empty. Create .env file with DISCORD_TOKEN field.");
            throw new Exception("Discord token not set or empty. Create .env file with DISCORD_TOKEN field.");
        }

        DiscordSocketConfig config = new()
        {
            GatewayIntents =
              GatewayIntents.Guilds | 
              GatewayIntents.GuildMessages | 
              GatewayIntents.DirectMessages | 
              GatewayIntents.MessageContent
        };

        _client = new DiscordSocketClient(config);

        _client.Log += LogAsync;
        _client.Ready += ReadyAsync;
        _client.MessageReceived += MessageReceivedAsync;
        _client.SlashCommandExecuted += SlashCommandHandler;
        _client.InteractionCreated += ButtonInteractionHandler;

        await _client.LoginAsync(TokenType.Bot, token);
        await _client.StartAsync();

        await Task.Delay(-1);
    }

    private Task LogAsync(LogMessage msg)
    {
        Console.WriteLine(msg.ToString());
        return Task.CompletedTask;
    }

    private async Task ReadyAsync()
    {
        SlashCommandBuilder interferenceCommand = new SlashCommandBuilder()
            .WithName("interference")
            .WithDescription("Print current known interfering software");
        SlashCommandBuilder candyCommand = new SlashCommandBuilder()
            .WithName("candy")
            .WithDescription("What to do with arcdps candy addons");

        try
        {
            ConsoleTrace("Initializing /commands.");
            await _client.CreateGlobalApplicationCommandAsync(interferenceCommand.Build());
            await _client.CreateGlobalApplicationCommandAsync(candyCommand.Build());
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex);
        }
    }

    private async Task MessageReceivedAsync(SocketMessage message)
    {
        if (message.Author.IsBot)
            return;

        ulong messageId;

        if (message.Attachments.Count > 0)
        {
            ConsoleTrace("Message with attachment received.");
            for (int i = 0; i < message.Attachments.Count; i++)
            {
                Attachment attachment = message.Attachments.ElementAt(i);

                log = await LogParser.DownloadAttachment(attachment);

                if (log.HasValidContent)
                {
                    ConsoleTrace("Attachment contains valid content, building embed.");

                    EmbedBuilder embedBuilder = new EmbedBuilder()
                        .WithColor(_blue)
                        .WithDescription("Summary of the log")
                        .WithTitle($"Analyzing {attachment.Filename}")
                        .WithFooter(_embedFooterBuilder)
                        .WithTimestamp(DateTimeOffset.Now);

                    messageId = message.Id;

                    string extensions = "";
                    string removeExtensions = "";
                    string warnings = string.Join("\n", log.Warnings);
                    string errors = string.Join("\n", log.Errors);
                    string stack = string.Join("\n", log.TopMostStackTraces.Select(kvp => $"{kvp.Key}"));
                    string causes = string.Join("\n", log.PossibleCauses);

                    // Loaded Extensions
                    foreach (Extension extension in log.Extensions)
                    {
                        extensions += extension.Name + "\n";
                        if (extension.Signature.Equals(Fastload_Candy) || extension.Signature.Equals(Gearcheck_Candy))
                        {
                            removeExtensions += extension.Path + "\n";
                        }
                    }
                    removeExtensions += string.Join("\n", log.WarningsLoadedExtensions);

                    // Loading method
                    switch (log.ArcDPS.Method)
                    {
                        case LoadMethod.Standalone:
                            AddEmbedNotEmptyField(embedBuilder, "ArcDPS", $"Build: {log.ArcDPS.Build} - Standalone");
                            break;
                        case LoadMethod.AddonLoader:
                            AddEmbedNotEmptyField(embedBuilder, "ArcDPS", $"Build: {log.ArcDPS.Build} - through Addon Loader");
                            break;
                        case LoadMethod.Nexus:
                            AddEmbedNotEmptyField(embedBuilder, "ArcDPS", $"Build: {log.ArcDPS.Build} - through Nexus");
                            break;
                        default:
                            AddEmbedNotEmptyField(embedBuilder, "ArcDPS", $"Build: {log.ArcDPS.Build} - Unknown load method");
                            break;
                    }

                    AddEmbedNotEmptyField(embedBuilder, "Extensions", extensions);
                    AddEmbedNotEmptyField(embedBuilder, "Warnings", warnings);
                    AddEmbedNotEmptyField(embedBuilder, "Errors", errors);
                    AddEmbedNotEmptyField(embedBuilder, "Stack", stack, true);

                    if (log.GameExit)
                    {
                        AddEmbedNotEmptyField(embedBuilder,
                            "Known cause",
                            "ArcDPS crashed during game shutdown.\n" +
                            "This is a known but rare issue with no identified cause.\n" +
                            "No action or report is required from the user.");
                    }

                    if (log.Errors.Any(x => x.Contains("nvwgf2umx.dll")))
                    {
                        AddEmbedNotEmptyField(embedBuilder,
                            "Known cause",
                            "The crash involves nvwgf2umx.dll (NVIDIA graphics driver).\n" +
                            "If you have updated recently, downgrade the drivers to a previous version.\n" +
                            "If there is another update available, try to upgrade to the latest version.");
                    }

                    AddEmbedNotEmptyField(embedBuilder, "Possible causes", causes);

                    // External software interference. Skip when loaded by Nexus.
                    if (log.ArcDPS.Method != LoadMethod.Nexus)
                    {
                        string interference = "";
                        HashSet<string> triggered = [];

                        foreach (string dll in log.SystemDlls)
                        {
                            foreach (var group in DllGroups)
                            {
                                if (triggered.Contains(group.Key))
                                    continue;

                                if (group.Value.Any(known => dll.Contains(known, StringComparison.OrdinalIgnoreCase)))
                                {
                                    interference += group.Key + "\n";
                                    triggered.Add(group.Key);
                                }
                            }
                        }

                        AddEmbedNotEmptyField(embedBuilder, "Interference", interference);
                    }

                    AddEmbedNotEmptyField(embedBuilder, "Remove extensions", removeExtensions);

                    MessageComponent component = new ComponentBuilder()
                        .WithButton("Print Stack Trace", $"{i}:{messageId}:0")
                        .WithButton("Print System Info", $"{i}:{messageId}:1")
                        .Build();

                    ConsoleTrace("Sending embed.");

                    await message.Channel.SendMessageAsync(embed: embedBuilder.Build(), components: component);
                }
                else if (log.IsValidFormat)
                {
                    ConsoleTrace("Attachment with invalid content, skipping parsing.");

                    EmbedBuilder embedBuilder = new EmbedBuilder()
                        .WithColor(_blue)
                        .WithTitle($"Analyzing {attachment.Filename}")
                        .WithFooter(_embedFooterBuilder)
                        .WithTimestamp(DateTimeOffset.Now);
                    embedBuilder.AddField("Not an ArcDPS crash log", "Skipped parsing.");

                    ConsoleTrace("Sending embed.");

                    await message.Channel.SendMessageAsync(embed: embedBuilder.Build());
                }
            }
        }
    }

    private async Task SlashCommandHandler(SocketSlashCommand command)
    {
        if (command.Data.Name == "interference")
        {
            ConsoleTrace("Interference command executed, building embed.");

            EmbedBuilder embedBuilder = new EmbedBuilder()
                .WithColor(_blue)
                .WithTitle("ArcDPS Interference")
                .AddField("The following software interfere with ArcDPS when loaded", $"{Software}")
                .AddField("The interference aren't present when loaded through Nexus", "https://discord.gg/raidcore")
                .AddField("Troubleshooting steps", "https://codimd.knox.moe/s/7i-MmOub5")
                .AddField("Further help needed?", "Ask in #arc-dps-issues channel")
                .WithFooter(_embedFooterBuilder)
                .WithTimestamp(DateTimeOffset.Now);

            ConsoleTrace("Sending interference command embed.");

            await command.RespondAsync(embed: embedBuilder.Build());
        }

        if (command.Data.Name == "candy")
        {
            ConsoleTrace("Candy command executed, building embed.");

            EmbedBuilder embedBuilder = new EmbedBuilder()
                .WithColor(_blue)
                .WithTitle("ArcDPS candy addons")
                .AddField("Do you have these addons?", "- arcdps_fastload\n- arcdps_gearcheck")
                .AddField("What to do?", "Please remove them before requesting further assistance.")
                .WithFooter(_embedFooterBuilder)
                .WithTimestamp(DateTimeOffset.Now);

            ConsoleTrace("Sending candy command embed.");

            await command.RespondAsync(embed: embedBuilder.Build());
        }
    }

    /// <summary>
    /// Buttons interaction attached to the embed message.
    /// </summary>
    private async Task ButtonInteractionHandler(SocketInteraction interaction)
    {
        ConsoleTrace("Embed button interacted.");

        if (interaction is not SocketMessageComponent component)
        {
            return;
        }

        string res;

        ConsoleTrace("Parsing custom id.");

        // AttachmentNumber : MessageID : ButtonID
        string[] ids = component.Data.CustomId.Split(':');
        ushort attachmentNumber = Convert.ToUInt16(ids[0]);
        ulong messageId = Convert.ToUInt64(ids[1]);
        ushort buttonId = Convert.ToUInt16(ids[2]);

        ConsoleTrace("Reading original attachment.");

        // Read the attachment in the original message
        IMessage message = await component.Channel.GetMessageAsync(messageId);

        if (message != null)
        {
            if (message.Attachments.Count > 0)
            {
                Attachment? attachment = message.Attachments.ElementAt(attachmentNumber) as Attachment;

                if (attachment == null)
                {
                    ConsoleTrace("Attachment not found.");
                    await component.RespondAsync("Attachment not found.", ephemeral: true);
                }

                log = await LogParser.DownloadAttachment(attachment!);

                if (!log.HasValidContent)
                {
                    ConsoleTrace("Skipped parsing: Not an ArcDPS crash log.");
                    await component.RespondAsync("Skipped parsing: Not an ArcDPS crash log.", ephemeral: true);
                }

                switch (buttonId)
                {
                    case 0:
                        ConsoleTrace("Button ID 0 interacted.");

                        if (log.StackTraces.Count > 0)
                        {
                            IEnumerable<string> lines = log.StackTraces.Select(x =>
                            {
                                string line = $"{x.Trace} - {x.Frame} - {x.Rva} - {x.FileShort}";
                                return x.ViaExport ? line + " (via export)" : line;
                            });

                            await SendChunkedStackTraceAsync(component, lines);
                        }
                        else
                        {
                            ConsoleTrace("Stack Trace not present.");
                            await component.RespondAsync("Stack trace not present.", ephemeral: true);
                        }
                        break;
                    case 1:
                        ConsoleTrace("Button ID 1 interacted.");

                        res = "```";
                        res += !string.IsNullOrEmpty(log.System.Wine) ? "Linux (corrected)\n" : "Windows: " + log.System.Windows + "\n";
                        res += "Cpu: " + log.System.Cpu + "\n";
                        res += "Ram: " + log.System.Ram + "\n";
                        res += "Gpu: " + log.System.Gpu + "\n";
                        res += !string.IsNullOrEmpty(log.System.Wine) ? "Wine: " + log.System.Wine + "\n" : "";
                        res += "```";

                        ConsoleTrace("System information printed.");

                        await component.RespondAsync(res, ephemeral: true);
                        break;
                    default:
                        break;
                }
            }
            else if (message.Attachments.Count == 0)
            {
                ConsoleTrace("Attachments not found.");
                await component.RespondAsync("Attachments not found.", ephemeral: true);
            }
        }
    }

    /// <summary>
    /// Adds a field to the embed verifying its content to not be null, white space or empty.
    /// </summary>
    private static void AddEmbedNotEmptyField(EmbedBuilder builder, string fieldHeader, string fieldBody, bool inline = false)
    {
        if (!string.IsNullOrWhiteSpace(fieldBody) && !string.IsNullOrEmpty(fieldBody))
        {
            builder.AddField(fieldHeader, fieldBody, inline);
        }
    }

    /// <summary>
    /// Sends the stack trace in code blocks chunked by the 2000 characters limit.
    /// </summary>
    private static async Task SendChunkedStackTraceAsync(SocketMessageComponent component, IEnumerable<string> lines)
    {
        const int limit = 2000;
        string current = $"```Trace ---------- Frame ---------- RVA ----- File Short ---\n";
        bool hasSent = false;

        foreach (string line in lines)
        {
            // +4 because we need space for ending "```"
            if (current.Length + line.Length + 4 >= limit)
            {
                // Close and start new chunk
                current += "```";
                await component.RespondAsync(current, ephemeral: true);
                hasSent = true;
                current = "```";
            }
            current += line + "\n";
        }

        // Send last block if anything remains
        if (hasSent && current.Length > 3)
        {
            current += "```";
            await component.FollowupAsync(current, ephemeral: true);
        }
        else
        {
            current += "```";
            await component.RespondAsync(current, ephemeral: true);
        }

        ConsoleTrace("Stack trace printed.");
    }

    /// <summary>
    /// Run this once when a /command needs to be deleted.
    /// </summary>
    public async Task DeleteSlashCommand(string commandName)
    {
        IReadOnlyCollection<SocketApplicationCommand> global = await _client.GetGlobalApplicationCommandsAsync();
        foreach (SocketApplicationCommand cmd in global)
        {
            if (cmd.Name == commandName)
            {
                await cmd.DeleteAsync();
                ConsoleTrace($"Deleted /{commandName} globally.");
            }
        }
    }
}
