using Discord;
using Discord.WebSocket;
using DotNetEnv;
using System.Text;
using static CrashLogAnalyzer.ArcDPS;
using static CrashLogAnalyzer.Interference;
using static CrashLogAnalyzer.Signatures;
using static CrashLogAnalyzer.Traces;

namespace CrashLogAnalyzer;

public class Program
{
    private DiscordSocketClient _client = new();
    private LogParser _log = new();
    private readonly Color _blue = new(4, 55, 242);

    private readonly EmbedFooterBuilder _embedFooterBuilder = new EmbedFooterBuilder()
        .WithText("Generated by Crash Log Analyzer")
        .WithIconUrl("https://i.imgur.com/Xafh24a.png");

    private const int MessagesTimeoutLimit = 10;

    private static Task Main() => new Program().MainAsync();

    private async Task MainAsync()
    {
        Env.Load();
        string? token = Environment.GetEnvironmentVariable("DISCORD_TOKEN");
#if DEBUG
        token = Environment.GetEnvironmentVariable("DISCORD_TOKEN_DEBUG");
#endif
        if (token is null || token.Length == 0)
        {
            ConsoleTrace("Discord token not set or empty. Create .env file with DISCORD_TOKEN field.");
            throw new Exception("Discord token not set or empty. Create .env file with DISCORD_TOKEN field.");
        }

        DiscordSocketConfig config = new()
        {
            GatewayIntents =
                GatewayIntents.Guilds |
                GatewayIntents.GuildMessages |
                GatewayIntents.DirectMessages |
                GatewayIntents.MessageContent
        };

        _client = new DiscordSocketClient(config);

        _client.Log += LogAsync;
        _client.Ready += ReadyAsync;
        _client.MessageReceived += MessageReceivedAsync;
        _client.SlashCommandExecuted += SlashCommandHandler;
        _client.InteractionCreated += ButtonInteractionHandler;

        await _client.LoginAsync(TokenType.Bot, token);
        await _client.StartAsync();

        await Task.Delay(-1);
    }

    private static Task LogAsync(LogMessage msg)
    {
        Console.WriteLine(msg.ToString());
        return Task.CompletedTask;
    }

    private async Task ReadyAsync()
    {
        SlashCommandBuilder interferenceCommand = new SlashCommandBuilder()
            .WithName("interference")
            .WithDescription("Print current known interfering software");
        SlashCommandBuilder candyCommand = new SlashCommandBuilder()
            .WithName("candy")
            .WithDescription("What to do with arcdps candy addons");
        SlashCommandBuilder infoCommand = new SlashCommandBuilder()
            .WithName("info")
            .WithDescription("Information regarding the bot and ArcDPS.");

        try
        {
            ConsoleTrace("Initializing /commands.");
            await _client.CreateGlobalApplicationCommandAsync(interferenceCommand.Build());
            await _client.CreateGlobalApplicationCommandAsync(candyCommand.Build());
            await _client.CreateGlobalApplicationCommandAsync(infoCommand.Build());
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex);
        }
    }

    private async Task MessageReceivedAsync(SocketMessage message)
    {
        if (message.Author.IsBot)
            return;

        if (message.Attachments.Count > 0)
        {
            ConsoleTrace("Message with attachment received.");
            for (int i = 0; i < message.Attachments.Count; i++)
            {
                Attachment attachment = message.Attachments.ElementAt(i);

                _log = await LogParser.DownloadAttachment(attachment);

                if (_log.HasValidContent)
                {
                    ConsoleTrace("Attachment contains valid content, building embed.");

                    EmbedBuilder embedBuilder = new EmbedBuilder()
                        .WithColor(_blue)
                        .WithDescription("Summary of the log")
                        .WithTitle($"Analyzing {attachment.Filename}")
                        .WithFooter(_embedFooterBuilder)
                        .WithTimestamp(DateTimeOffset.Now);

                    ulong messageId = message.Id;

                    string extensions = "";
                    string removeExtensions = "";
                    string warnings = string.Join("\n", _log.Warnings);
                    string errors = string.Join("\n", _log.Errors);
                    string stack = string.Join("\n", _log.TopMostStackTraces.Select(kvp => $"{kvp.Key}"));
                    string causes = string.Join("\n", _log.PossibleCauses);

                    // Loaded extensions and to be removed extensions
                    foreach (Extension extension in _log.Extensions)
                    {
                        extensions += $"{extension.Name} - {extension.Version}\n";
                        if (extension.Signature.Equals(Fastload_Candy) ||
                            extension.Signature.Equals(Gearcheck_Candy) ||
                            extension.Signature.Equals(KnowThyEnemy))
                        {
                            removeExtensions += extension.Path + " - (unsupported)\n";
                        }
                    }

                    foreach (string ext in _log.WarningsLoadedExtensions)
                    {
                        removeExtensions += ext + " - (duplicated)\n";
                    }

                    // Loading method
                    switch (_log.ArcDPS.Method)
                    {
                        case LoadMethod.Standalone:
                            AddEmbedNotEmptyField(embedBuilder, "ArcDPS", $"Build: {_log.ArcDPS.Build} - Standalone");
                            break;
                        case LoadMethod.AddonLoader:
                            AddEmbedNotEmptyField(embedBuilder, "ArcDPS", $"Build: {_log.ArcDPS.Build} - through Addon Loader");
                            break;
                        case LoadMethod.Nexus:
                            AddEmbedNotEmptyField(embedBuilder, "ArcDPS", $"Build: {_log.ArcDPS.Build} - through Nexus");
                            break;
                        default:
                            AddEmbedNotEmptyField(embedBuilder, "ArcDPS", $"Build: {_log.ArcDPS.Build} - Unknown load method");
                            break;
                    }

                    AddEmbedNotEmptyField(embedBuilder, "Extensions", extensions);
                    AddEmbedNotEmptyField(embedBuilder, "Warnings", warnings);
                    AddEmbedNotEmptyField(embedBuilder, "Errors", errors);
                    AddEmbedNotEmptyField(embedBuilder, "Stack", stack, true);

                    if (_log.GameExit)
                    {
                        AddEmbedNotEmptyField(embedBuilder,
                            "Known cause",
                            "ArcDPS crashed during game shutdown.\n" +
                            "This is a known but rare issue with no identified cause.\n" +
                            "No action or report is required from the user.");
                    }

                    if (_log.Errors.Any(x => x.Contains("nvwgf2umx.dll")))
                    {
                        AddEmbedNotEmptyField(embedBuilder,
                            "Known cause",
                            "The crash involves nvwgf2umx.dll (NVIDIA graphics driver).\n" +
                            "If you have updated recently, downgrade the drivers to a previous version.\n" +
                            "If there is another update available, try to upgrade to the latest version.\n" +
                            "This could also be caused by Guild Wars 2 or a silent issue in ArcDPS or extensions.");
                    }

                    AddEmbedNotEmptyField(embedBuilder, "Possible causes", causes);

                    // External software interference. Skip when loaded by Nexus.
                    if (_log.ArcDPS.Method != LoadMethod.Nexus)
                    {
                        string interference = "";
                        HashSet<string> triggered = [];

                        foreach (string dll in _log.SystemDlls)
                        {
                            foreach (var group in DllGroups)
                            {
                                if (triggered.Contains(group.Key))
                                    continue;

                                if (group.Value.Any(known => dll.Contains(known, StringComparison.OrdinalIgnoreCase)))
                                {
                                    interference += group.Key + "\n";
                                    triggered.Add(group.Key);
                                }
                            }
                        }

                        AddEmbedNotEmptyField(embedBuilder, "Interference", interference);
                    }

                    AddEmbedNotEmptyField(embedBuilder, "Remove extensions", removeExtensions);

                    MessageComponent component = new ComponentBuilder()
                        .WithButton("Stack Trace", $"{i}:{messageId}:0")
                        .WithButton("System Info", $"{i}:{messageId}:1")
                        .WithButton("Exception Info", $"{i}:{messageId}:2")
                        .WithButton("Loaded Files", $"{i}:{messageId}:3")
                        .Build();

                    ConsoleTrace("Sending embed.");

                    await message.Channel.SendMessageAsync(embed: embedBuilder.Build(), components: component);
                }
                else if (_log.IsValidFormat)
                {
                    ConsoleTrace("Attachment with invalid content, skipping parsing.");

                    EmbedBuilder embedBuilder = new EmbedBuilder()
                        .WithColor(_blue)
                        .WithTitle($"Analyzing {attachment.Filename}")
                        .WithFooter(_embedFooterBuilder)
                        .WithTimestamp(DateTimeOffset.Now);
                    embedBuilder.AddField("Not an ArcDPS crash log", "Skipped parsing.");

                    ConsoleTrace("Sending embed.");

                    await message.Channel.SendMessageAsync(embed: embedBuilder.Build());
                }
            }
        }
    }

    private async Task SlashCommandHandler(SocketSlashCommand command)
    {
        switch (command.Data.Name)
        {
            case "interference":
                ConsoleTrace("Interference command executed, building embed.");

                EmbedBuilder interferenceBuilder = new EmbedBuilder()
                    .WithColor(_blue)
                    .WithTitle("ArcDPS Interference")
                    .AddField("The following software interfere with ArcDPS when loaded", $"{Software}")
                    .AddField("The interference aren't present when loaded through Nexus", "https://discord.gg/raidcore")
                    .AddField("Troubleshooting steps", "https://codimd.knox.moe/s/7i-MmOub5")
                    .AddField("Further help needed?", "Ask in #arc-dps-issues channel")
                    .WithFooter(_embedFooterBuilder)
                    .WithTimestamp(DateTimeOffset.Now);

                ConsoleTrace("Sending interference command embed.");

                await command.RespondAsync(embed: interferenceBuilder.Build());
                break;
            case "candy":
                ConsoleTrace("Candy command executed, building embed.");

                EmbedBuilder candyBuilder = new EmbedBuilder()
                    .WithColor(_blue)
                    .WithTitle("ArcDPS candy addons")
                    .AddField("Do you have these addons?", "- arcdps_fastload\n- arcdps_gearcheck")
                    .AddField("What to do?", "Please remove them before requesting further assistance.")
                    .WithFooter(_embedFooterBuilder)
                    .WithTimestamp(DateTimeOffset.Now);

                ConsoleTrace("Sending candy command embed.");

                await command.RespondAsync(embed: candyBuilder.Build());
                break;
            case "info":
                ConsoleTrace("Info command executed, building embed.");

                EmbedBuilder infoBuilder = new EmbedBuilder()
                    .WithColor(_blue)
                    .WithTitle("Crash Log Analyzer")
                    .WithDescription("This bot analyzes ArcDPS crash logs and provides a summary with inspection features.")
                    .AddField("Source Code", "https://github.com/Linkaaaaa/CrashLogAnalyzer")
                    .AddField("ArcDPS", "https://www.deltaconnected.com/arcdps/")
                    .AddField("Elite Insights", "https://discord.gg/T4kSbKJ5Sf")
                    .AddField("Raidcore", "https://discord.gg/raidcore")
                    .AddField("Troubleshooting", "https://codimd.knox.moe/s/7i-MmOub5")
                    .WithFooter(_embedFooterBuilder)
                    .WithTimestamp(DateTimeOffset.Now);

                ConsoleTrace("Sending info command embed.");

                await command.RespondAsync(embed: infoBuilder.Build());
                break;
        }
    }

    /// <summary>
    /// Buttons interaction attached to the embed message.
    /// </summary>
    private async Task ButtonInteractionHandler(SocketInteraction interaction)
    {
        ConsoleTrace("Embed button interacted.");

        if (interaction is not SocketMessageComponent component)
        {
            return;
        }

        ConsoleTrace("Parsing custom id.");

        // AttachmentNumber : MessageID : ButtonID
        string[] ids = component.Data.CustomId.Split(':');
        ushort attachmentNumber = Convert.ToUInt16(ids[0]);
        ulong messageId = Convert.ToUInt64(ids[1]);
        ushort buttonId = Convert.ToUInt16(ids[2]);

        ConsoleTrace("Reading original attachment.");

        // Read the attachment in the original message
        IMessage message = await component.Channel.GetMessageAsync(messageId);

        if (message != null && message.Attachments.Count > 0)
        {
            Attachment? attachment = message.Attachments.ElementAt(attachmentNumber) as Attachment;

            if (attachment == null)
            {
                ConsoleTrace("Attachment not found.");
                await component.RespondAsync("Attachment not found.", ephemeral: true);
            }

            _log = await LogParser.DownloadAttachment(attachment!);

            if (!_log.HasValidContent)
            {
                ConsoleTrace("Skipped parsing: Not an ArcDPS crash log.");
                await component.RespondAsync("Skipped parsing: Not an ArcDPS crash log.", ephemeral: true);
            }

            string res;

            switch (buttonId)
            {
                case 0:
                    ConsoleTrace("Button ID 0 interacted.");

                    if (_log.StackTraces.Count > 0)
                    {
                        string[] lines =
                        [
                            .. _log.StackTraces.Select(x =>
                            {
                                string line = $"{x.Trace} - {x.Frame} - {x.Rva} - {x.FileShort}";
                                return x.ViaExport ? line + " (via export)" : line;
                            })
                        ];

                        List<string> chunks = SplitIntoChunks(lines,
                            "Trace ---------- Frame ---------- RVA ----- File Short ---\n");
                        ConsoleTrace($"Response Chunks: {chunks.Count}");

                        if (chunks.Count > MessagesTimeoutLimit)
                        {
                            await component.RespondAsync("```\nStack trace too long, download the log file.\n```",
                                ephemeral: true);
                        }
                        else
                        {
                            for (int i = 0; i < chunks.Count; i++)
                            {
                                string line = chunks[i];
                                if (i == 0)
                                {
                                    await component.RespondAsync(line, ephemeral: true);
                                }
                                else
                                {
                                    await component.FollowupAsync(line, ephemeral: true);
                                }

                                ConsoleTrace($"Stack Trace printed. - {i}");
                            }
                        }
                    }
                    else
                    {
                        ConsoleTrace("Stack Trace not present.");
                        await component.RespondAsync("Stack trace not present.", ephemeral: true);
                    }

                    break;
                case 1:
                    ConsoleTrace("Button ID 1 interacted.");

                    res = "```\n";
                    res += !string.IsNullOrEmpty(_log.System.Wine)
                        ? "Linux (corrected)\n"
                        : "Windows: " + _log.System.Windows + "\n";
                    res += "Cpu: " + _log.System.Cpu + "\n";
                    res += "Ram: " + _log.System.Ram + "\n";
                    res += "Gpu: " + _log.System.Gpu + "\n";
                    res += "Vram: " + _log.System.Vram + "\n";
                    res += !string.IsNullOrEmpty(_log.System.Wine) ? "Wine: " + _log.System.Wine + "\n" : "";
                    res += "```";

                    ConsoleTrace("System information printed.");

                    await component.RespondAsync(res, ephemeral: true);
                    break;
                case 2:
                    ConsoleTrace("Button ID 2 interacted.");

                    res = "```\n";
                    res += "Code: " + _log.ExceptionInfo.Code + "\n";
                    res += "Address: " + _log.ExceptionInfo.Address + "\n";
                    res += "Flags: " + _log.ExceptionInfo.Flags + "\n";
                    res += "```";

                    ConsoleTrace("Exception Information printed.");

                    await component.RespondAsync(res, ephemeral: true);
                    break;
                case 3:
                    ConsoleTrace("Button ID 3 interacted.");

                    if (_log.SystemFiles.Count > 0)
                    {
                        string[] filesLines = [.. _log.SystemFiles.OrderBy(x => x.Path).Select(x => x.Path)];

                        List<string> moduleChunks = SplitIntoChunks(filesLines);
                        ConsoleTrace($"Response Chunks: {moduleChunks.Count}");

                        if (moduleChunks.Count > MessagesTimeoutLimit)
                        {
                            await component.RespondAsync(
                                "```\nLoaded system modules too long, download the log file.\n```", ephemeral: true);
                        }
                        else
                        {
                            for (int i = 0; i < moduleChunks.Count; i++)
                            {
                                string line = moduleChunks[i];
                                if (i == 0)
                                {
                                    await component.RespondAsync(line, ephemeral: true);
                                }
                                else
                                {
                                    await component.FollowupAsync(line, ephemeral: true);
                                }

                                ConsoleTrace($"Loaded system modules alphabetically printed - {i}.");
                            }
                        }
                    }
                    else
                    {
                        ConsoleTrace("Loaded system modules not present.");
                        await component.RespondAsync("Loaded system modules not present.", ephemeral: true);
                    }

                    break;
            }
        }
        else
        {
            const string errorMessage = "Attachments or original message not found.";
            ConsoleTrace(errorMessage);
            await component.RespondAsync(errorMessage, ephemeral: true);
        }
    }

    /// <summary>
    /// Adds a field to the embed verifying its content to not be null, white space or empty.
    /// </summary>
    private static void AddEmbedNotEmptyField(EmbedBuilder builder, string fieldHeader, string fieldBody, bool inline = false)
    {
        if (!string.IsNullOrWhiteSpace(fieldBody) && !string.IsNullOrEmpty(fieldBody))
        {
            builder.AddField(fieldHeader, fieldBody, inline);
        }
    }

    /// <summary>
    /// Splits a collection of lines into multiple Markdown code blocks limited to 2000 characters each.
    /// </summary>
    /// <param name="lines">The lines of text to include inside the code blocks.</param>
    /// <param name="header">Optional text inserted at the beginning of the first code block.</param>
    /// <returns>A list of markdown-formatted code block strings.</returns>
    private static List<string> SplitIntoChunks(string[] lines, string header = "")
    {
        const int maxLength = 2000;
        const string start = "```\n";
        const string end = "\n```";

        List<string> res = [];
        StringBuilder sb = new();
        sb.Append(start);
        if (!string.IsNullOrEmpty(header))
        {
            sb.Append(header);
        }

        foreach (string line in lines)
        {
            string lineWithNewline = line + "\n";

            // If this line won't fit, close current block and start a new one
            if (sb.Length + lineWithNewline.Length + end.Length > maxLength)
            {
                sb.Append(end);
                res.Add(sb.ToString());

                sb.Clear();
                sb.Append(start);
            }

            sb.Append(lineWithNewline);
        }

        // Close final block if it has content
        if (sb.Length > start.Length)
        {
            sb.Append(end);
            res.Add(sb.ToString());
        }

        return res;
    }

    /// <summary>
    /// Run this once when a /command needs to be deleted.
    /// </summary>
    public async Task DeleteSlashCommand(string commandName)
    {
        IReadOnlyCollection<SocketApplicationCommand> global = await _client.GetGlobalApplicationCommandsAsync();
        foreach (SocketApplicationCommand cmd in global)
        {
            if (cmd.Name == commandName)
            {
                await cmd.DeleteAsync();
                ConsoleTrace($"Deleted /{commandName} globally.");
            }
        }
    }
}